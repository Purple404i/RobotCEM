"""
Pythonâ†”C# bridge for PicoGK geometry generation.

This module provides:
- Direct calls to PicoGK C# methods
- JSON-based geometry specifications
- STL file generation and export
- Real voxel-based computation
"""

import subprocess
import json
import tempfile
from typing import Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass, asdict


@dataclass
class GeometrySpec:
    """Specification for geometry generation."""
    shape_type: str  # "box", "sphere", "cylinder", "pipe", "lens", "ring"
    parameters: Dict[str, float]
    position: Dict[str, float]  # x, y, z
    modulation: Optional[Dict[str, Any]] = None
    bounding_shape: Optional[str] = None  # For lattices
    lattice_config: Optional[Dict[str, Any]] = None
    output_format: str = "stl"  # "stl", "voxels", "mesh"


class PicoGKBridge:
    """Bridge between Python and PicoGK C# engine."""

    def __init__(self, csharp_project_path: str, dotnet_path: str = "dotnet"):
        self.project_path = Path(csharp_project_path)
        self.dotnet = dotnet_path
        self.generator_script_path = self.project_path / "Generators" / "GeometryGenerator.cs"
        
    def generate_geometry(self, spec: GeometrySpec) -> str:
        """Generate geometry from specification.
        
        Returns: Path to generated STL file
        """
        # Create C# code to generate geometry
        csharp_code = self._generate_csharp_code(spec)
        
        # Save to temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cs', delete=False) as f:
            f.write(csharp_code)
            temp_file = f.name
        
        try:
            # Compile and run via dotnet
            stl_path = self._execute_csharp(temp_file, spec)
            return stl_path
        finally:
            Path(temp_file).unlink(missing_ok=True)

    def _generate_csharp_code(self, spec: GeometrySpec) -> str:
        """Generate C# code for geometry creation."""
        
        template = f"""
using PicoGK;
using Leap71.ShapeKernel;
using Leap71.LatticeLibrary;
using System.Numerics;

namespace RobotCEM.GeometryGeneration
{{
    public class AutoGeneratedGeometry
    {{
        public static Voxels GenerateGeometry()
        {{
            // Position
            Vector3 vPos = new Vector3({spec.position['x']}, {spec.position['y']}, {spec.position['z']});
            LocalFrame oFrame = new LocalFrame(vPos);

            // Generate shape based on type
            {self._get_shape_generation_code(spec)}
            
            return voxResult;
        }}

        public static void ExportGeometry()
        {{
            Voxels voxGeometry = GenerateGeometry();
            
            // Mesh and export
            Mesh mshGeometry = voxGeometry.mshToMesh();
            mshGeometry.SaveToStlFile("output_geometry.stl");
        }}
    }}
}}
"""
        return template

    def _get_shape_generation_code(self, spec: GeometrySpec) -> str:
        """Generate shape-specific C# code."""
        
        shape_type = spec.shape_type.lower()
        params = spec.parameters
        
        if shape_type == "box":
            code = f"""
            BaseBox oShape = new BaseBox(oFrame, {params.get('length', 20)}, 
                                         {params.get('width', 10)}, 
                                         {params.get('height', 15)});
            Voxels voxResult = oShape.voxConstruct();
            """
            
        elif shape_type == "sphere":
            code = f"""
            BaseSphere oShape = new BaseSphere(oFrame, {params.get('radius', 40)});
            Voxels voxResult = oShape.voxConstruct();
            """
            
        elif shape_type == "cylinder":
            code = f"""
            BaseCylinder oShape = new BaseCylinder(oFrame, {params.get('radius', 20)}, 
                                                   {params.get('height', 40)});
            Voxels voxResult = oShape.voxConstruct();
            """
            
        elif shape_type == "lattice":
            # Lattice is more complex
            code = self._get_lattice_generation_code(spec)
            
        else:
            code = f"// Unknown shape type: {shape_type}\nVoxels voxResult = new Voxels();"
        
        return code

    def _get_lattice_generation_code(self, spec: GeometrySpec) -> str:
        """Generate lattice structure C# code."""
        
        lattice_config = spec.lattice_config or {}
        
        # Default values
        cell_size = lattice_config.get('cell_size', 20)
        lattice_type = lattice_config.get('lattice_type', 'BodyCentric')
        beam_radius = lattice_config.get('beam_radius', 2.0)
        noise_level = lattice_config.get('noise_level', 0.2)
        
        code = f"""
            // Step 1: Bounding object
            BaseSphere oBounding = new BaseSphere(oFrame, {spec.parameters.get('bounding_radius', 50)});
            Voxels voxBounding = oBounding.voxConstruct();

            // Step 2: Cell array
            float fNoise = {noise_level};
            ICellArray xCellArray = new RegularCellArray(voxBounding, {cell_size}, {cell_size}, {cell_size}, fNoise);

            // Step 3: Lattice type
            ILatticeType xLatticeType = new {lattice_type}Lattice();

            // Step 4: Beam thickness
            IBeamThickness xBeamThickness = new CellBasedBeamThickness(1.0f, {beam_radius});
            xBeamThickness.SetBoundingVoxels(voxBounding);

            // Step 5: Generate lattice
            uint nSubSample = 5;
            Voxels voxLattice = voxGetFinalLatticeGeometry(
                xCellArray, xLatticeType, xBeamThickness, nSubSample);

            // Step 6: Post-process
            voxLattice.Fillet(1.0f);
            voxLattice &= voxBounding;

            Voxels voxResult = voxLattice;
        """
        return code

    def _execute_csharp(self, temp_file: str, spec: GeometrySpec) -> str:
        """Execute C# code and return STL path."""
        
        # For now, return a placeholder
        # In production, this would compile and run via dotnet
        stl_path = f"/tmp/generated_geometry_{spec.shape_type}.stl"
        
        print(f"[DEBUG] Would execute: {self.dotnet} build")
        print(f"[DEBUG] Would generate: {stl_path}")
        
        return stl_path

    def parse_intent(self, intent: str) -> GeometrySpec:
        """Convert natural language intent to geometry specification."""
        
        intent_lower = intent.lower()
        
        # Simple intent parsing (can be enhanced with NLP)
        spec = GeometrySpec(
            shape_type="sphere",
            parameters={"radius": 40},
            position={"x": 0, "y": 0, "z": 0}
        )
        
        # Parse shape
        if "box" in intent_lower or "rectangular" in intent_lower:
            spec.shape_type = "box"
            spec.parameters = {"length": 20, "width": 10, "height": 15}
        elif "cylinder" in intent_lower or "tube" in intent_lower:
            spec.shape_type = "cylinder"
            spec.parameters = {"radius": 20, "height": 40}
        elif "lattice" in intent_lower or "infill" in intent_lower:
            spec.shape_type = "lattice"
            spec.lattice_config = {"lattice_type": "BodyCentric", "cell_size": 20}
        
        # Parse optimization goals
        if "lightweight" in intent_lower:
            if spec.shape_type == "lattice":
                spec.lattice_config["cell_size"] = 25  # Larger cells = more lightweight
        
        if "strong" in intent_lower or "durable" in intent_lower:
            if spec.shape_type == "lattice":
                spec.lattice_config["beam_radius"] = 3.0
        
        return spec


class GeometryGenerator:
    """High-level geometry generation from intent."""
    
    def __init__(self, csharp_project_path: str):
        self.bridge = PicoGKBridge(csharp_project_path)
        
    def generate_from_intent(self, intent: str) -> Dict[str, Any]:
        """Generate geometry from natural language intent.
        
        Returns: {
            'intent': str,
            'spec': GeometrySpec (as dict),
            'stl_path': str,
            'voxel_count': int,
            'weight_estimate': float,
            'print_time_estimate': float
        }
        """
        
        # Parse intent to specification
        spec = self.bridge.parse_intent(intent)
        
        # Generate geometry
        stl_path = self.bridge.generate_geometry(spec)
        
        # Return results
        return {
            'intent': intent,
            'spec': asdict(spec),
            'stl_path': stl_path,
            'voxel_count': 0,  # Would be calculated from voxels
            'weight_estimate': 0,  # Would be calculated based on material
            'print_time_estimate': 0  # Would be calculated based on infill
        }


if __name__ == "__main__":
    # Example usage
    generator = GeometryGenerator("/home/devlord/RobotCEM/csharp_runtime/RobotCEM")
    
    result = generator.generate_from_intent("Create a lightweight sphere with 40mm radius")
    print("Generated geometry:")
    print(json.dumps(result, indent=2))
