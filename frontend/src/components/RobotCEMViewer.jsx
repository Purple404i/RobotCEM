/**
 * STL Viewer Component for RobotCEM
 * Displays 3D geometry generated by PicoGK using Three.js and React Three Fiber
 */

import React, { useRef, useState, useEffect, Suspense } from 'react';
import { Canvas, useFrame, useLoader } from '@react-three/fiber';
import { OrbitControls, Grid, PerspectiveCamera, Environment } from '@react-three/drei';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';
import * as THREE from 'three';

/**
 * STL Model Component
 * Loads and displays a single STL file
 */
function STLModel({ url, color = "#4a9eff", wireframe = false }) {
  const meshRef = useRef();
  const [rotation, setRotation] = useState(0);
  
  // Load STL geometry
  const geometry = useLoader(STLLoader, url);
  
  // Center the geometry
  useEffect(() => {
    if (geometry) {
      geometry.center();
      geometry.computeVertexNormals();
    }
  }, [geometry]);
  
  // Optional rotation animation
  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.y += delta * 0.1;
    }
  });
  
  return (
    <mesh ref={meshRef} geometry={geometry}>
      <meshStandardMaterial
        color={color}
        metalness={0.3}
        roughness={0.4}
        wireframe={wireframe}
      />
    </mesh>
  );
}

/**
 * Main STL Viewer Component
 */
export default function RobotCEMViewer({ 
  stlUrl, 
  backgroundColor = "#1a1a1a",
  gridColor = "#444444",
  showGrid = true,
  showAxes = true,
  enableRotation = true
}) {
  const [viewMode, setViewMode] = useState('solid'); // 'solid', 'wireframe', 'both'
  const [autoRotate, setAutoRotate] = useState(false);
  const [metadata, setMetadata] = useState(null);
  
  // Load metadata
  useEffect(() => {
    if (stlUrl) {
      const metaUrl = stlUrl.replace('.stl', '_meta.json');
      fetch(metaUrl)
        .then(res => res.json())
        .then(data => setMetadata(data))
        .catch(err => console.log('No metadata available'));
    }
  }, [stlUrl]);
  
  return (
    <div style={{ width: '100%', height: '100vh', position: 'relative' }}>
      {/* Three.js Canvas */}
      <Canvas
        shadows
        dpr={[1, 2]}
        camera={{ position: [50, 50, 50], fov: 50 }}
        style={{ background: backgroundColor }}
      >
        {/* Lighting */}
        <ambientLight intensity={0.4} />
        <directionalLight
          position={[10, 10, 5]}
          intensity={1}
          castShadow
          shadow-mapSize-width={1024}
          shadow-mapSize-height={1024}
        />
        <pointLight position={[-10, -10, -10]} intensity={0.5} />
        
        {/* Grid and Axes */}
        {showGrid && (
          <Grid
            args={[100, 100]}
            cellSize={5}
            cellColor={gridColor}
            sectionSize={10}
            sectionColor="#666666"
            fadeDistance={200}
            fadeStrength={1}
            infiniteGrid
          />
        )}
        
        {showAxes && (
          <primitive object={new THREE.AxesHelper(20)} />
        )}
        
        {/* STL Model */}
        <Suspense fallback={<LoadingIndicator />}>
          {stlUrl && (
            <>
              {(viewMode === 'solid' || viewMode === 'both') && (
                <STLModel url={stlUrl} color="#4a9eff" wireframe={false} />
              )}
              {(viewMode === 'wireframe' || viewMode === 'both') && (
                <STLModel 
                  url={stlUrl} 
                  color={viewMode === 'both' ? "#00ff00" : "#ffffff"} 
                  wireframe={true} 
                />
              )}
            </>
          )}
        </Suspense>
        
        {/* Camera Controls */}
        <OrbitControls
          enablePan={true}
          enableZoom={true}
          enableRotate={enableRotation}
          autoRotate={autoRotate}
          autoRotateSpeed={2}
        />
        
        {/* Environment for better lighting */}
        <Environment preset="city" />
      </Canvas>
      
      {/* UI Controls */}
      <ViewerControls
        viewMode={viewMode}
        setViewMode={setViewMode}
        autoRotate={autoRotate}
        setAutoRotate={setAutoRotate}
        metadata={metadata}
      />
    </div>
  );
}

/**
 * Loading Indicator
 */
function LoadingIndicator() {
  return (
    <mesh>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="orange" wireframe />
    </mesh>
  );
}

/**
 * Viewer Controls Panel
 */
function ViewerControls({ viewMode, setViewMode, autoRotate, setAutoRotate, metadata }) {
  const [showMetadata, setShowMetadata] = useState(false);
  
  return (
    <>
      {/* Control Panel */}
      <div style={{
        position: 'absolute',
        top: '20px',
        right: '20px',
        background: 'rgba(0, 0, 0, 0.7)',
        padding: '15px',
        borderRadius: '8px',
        color: 'white',
        fontFamily: 'Arial, sans-serif',
        minWidth: '200px'
      }}>
        <h3 style={{ margin: '0 0 10px 0', fontSize: '16px' }}>View Controls</h3>
        
        <div style={{ marginBottom: '10px' }}>
          <label style={{ fontSize: '12px', display: 'block', marginBottom: '5px' }}>
            Display Mode
          </label>
          <select
            value={viewMode}
            onChange={(e) => setViewMode(e.target.value)}
            style={{
              width: '100%',
              padding: '5px',
              borderRadius: '4px',
              background: '#333',
              color: 'white',
              border: '1px solid #555'
            }}
          >
            <option value="solid">Solid</option>
            <option value="wireframe">Wireframe</option>
            <option value="both">Both</option>
          </select>
        </div>
        
        <div style={{ marginBottom: '10px' }}>
          <label style={{ fontSize: '12px', cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={autoRotate}
              onChange={(e) => setAutoRotate(e.target.checked)}
              style={{ marginRight: '8px' }}
            />
            Auto Rotate
          </label>
        </div>
        
        {metadata && (
          <div style={{ marginTop: '10px' }}>
            <button
              onClick={() => setShowMetadata(!showMetadata)}
              style={{
                width: '100%',
                padding: '8px',
                background: '#4a9eff',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px'
              }}
            >
              {showMetadata ? 'Hide' : 'Show'} Metadata
            </button>
          </div>
        )}
        
        <div style={{ marginTop: '10px', fontSize: '11px', color: '#aaa' }}>
          <div>üñ±Ô∏è Left Click: Rotate</div>
          <div>üñ±Ô∏è Right Click: Pan</div>
          <div>üñ±Ô∏è Scroll: Zoom</div>
        </div>
      </div>
      
      {/* Metadata Panel */}
      {showMetadata && metadata && (
        <div style={{
          position: 'absolute',
          bottom: '20px',
          left: '20px',
          background: 'rgba(0, 0, 0, 0.8)',
          padding: '15px',
          borderRadius: '8px',
          color: 'white',
          fontFamily: 'monospace',
          fontSize: '12px',
          maxWidth: '400px'
        }}>
          <h3 style={{ margin: '0 0 10px 0', fontSize: '14px' }}>Design Metadata</h3>
          <div style={{ display: 'grid', gridTemplateColumns: '120px 1fr', gap: '5px' }}>
            {Object.entries(metadata).map(([key, value]) => (
              <React.Fragment key={key}>
                <div style={{ color: '#4a9eff' }}>{key}:</div>
                <div>{typeof value === 'object' ? JSON.stringify(value) : String(value)}</div>
              </React.Fragment>
            ))}
          </div>
        </div>
      )}
    </>
  );
}

/**
 * Hook for loading STL from backend
 */
export function useRobotCEMDesign(designId) {
  const [stlUrl, setStlUrl] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (designId) {
      setLoading(true);
      fetch(`/api/designs/${designId}/stl`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to load STL');
          return res.blob();
        })
        .then(blob => {
          const url = URL.createObjectURL(blob);
          setStlUrl(url);
          setLoading(false);
        })
        .catch(err => {
          setError(err.message);
          setLoading(false);
        });
    }
    
    return () => {
      if (stlUrl) {
        URL.revokeObjectURL(stlUrl);
      }
    };
  }, [designId]);
  
  return { stlUrl, loading, error };
}